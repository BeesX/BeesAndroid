# 大型Android项目的工程化实践：模块化

**关于作者**

>郭孝星，程序员，吉他手，主要从事Android平台基础架构方面的工作，欢迎交流技术方面的问题，可以去我的[Github](https://github.com/guoxiaoxing)提issue或者发邮件至guoxiaoxingse@163.com与我交流。

**文章目录**

- 一 发现问题
- 二 提出方案
    - 2.1 模块架构
    - 2.2 模块解耦
    - 2.3 模块通信
- 三 解决问题

模块化也是近两年经常被提及的一个技术点，究其原因，随着公司业务的逐渐壮大，主应用的工程体积也逐渐变大，管理和编译都变得十分困难。再加上随着公司业务的发展，主应用功能拆分和研发团队的拆分已成必然，这就要求
主应用里的各个模块能够独立编译、独立运行、不与主工程以及其他模块相互耦合。

而模块化实践起来并不是一件简单的事情，每家的应用都有自己的特殊情况，没有放之四海而皆准的技术方案，整体上来说，模块的拆分牵扯工程框架（MVP）、模块通信（跨进程）、library多端复用、资源拆分等多种
情况，那么模块化最终要达到一个什么样的目标呢？🤔

- 主应用的其他模块可以快速移植到其他应用。
- 减少Build时间，各模块交由各团队独立负责，代码责任制。
- 主应用的各模块可以拆分成独立的应用，模块功能服务化。
- 模块可以独立开发、独立编译、独立运行，无需借助任何主工程环境，模块之间可以快速替换。
- 无侵入式的配置各种独立服务，例如：账户信息、设置信息、网络服务、图片加载服务、埋点服务、下拉刷新样式、错误状态等。
- Library可以快速便捷的在多端使用。库里功能尽量独立在View或者Fragment，在使用的时候可以直接添加到宿主Activity里，宿主Activity可以自己添加下载刷新样式、Action bar样式等。

理解了具体的模块化需求，我们接下来开始真正的开始进行模块化，光说不练假把式，空谈没有任何意义。下面的模块化都是围绕着我司主应用**大风车**而展开的。

广告时间到😎

大风车：http://dafengche.souche.com/

> 一款SaaS产品，提供建站系统、ERP、CRM、微信营销系统、财务系统等解决方案，旨在帮助车商及4S集团提升运营和管理水平。

<img src="https://github.com/BeesAndroid/BeesAndroid/blob/master/art/practice/project/module/dafengche_banner.png"/>

在分析方案之前，首先我们要知道我们的应用出了什么问题，针对大风车这个项目，我们来具体分析下。

## 一 发现问题

大风车与2015年上线，经过三年的发展，业务有了很大的增长，功能也逐渐完善，大风车里程碑如下所示：

<img src="https://github.com/BeesAndroid/BeesAndroid/blob/master/art/practice/project/module/dafengche_banner.png"/>

我们和其他团队一样，在业务的发展中，主工程的架构也在不断的变化，我简单总结一下：

1. 微型项目：早期就是一个工程，几个人，那个时候也是业务跑量的时候，没有特别注意架构桑的问题。
2. 小型项目：随着业务的发展，业务种类也逐渐增多，这个时候我们就把一些业务模块拆分成了独立的Library，体抽了一个Base Library，提供了一些工具库和样式上的东西。
3. 中型项目：业务进一步增长，单纯搞Module Library已经不好用了，这个时间插件化框架很火，很强大，但是问题也很多，我们最终采用了Router的方式实现了一套**伪模块化方案**。
4. 大型项目：时间来到了现在，公司业务有了爆发式的增长，公司的应用也有原来的2个变成了5个，而且还有很多定制App、影子App，模块App等需求提交给我们，在上一套**伪模块化方案**的基础
上，我们要实现一套真正的模块化方案。

    
工程也变得十分巨大，编译和维护都比较困难，




大风车工程层级结构如下图所示：

<img src="https://github.com/BeesAndroid/BeesAndroid/blob/master/art/practice/project/module/dafengche_structure.png"/>

可以看到整个大风车的主工程可以分为四层：

- 主工程业务层
- 模块业务层
- 公司框架层
- 第三方框架层

所以你可以看到这个工程与模块之间、模块与模块之间的依赖关系真的是美如画😅，相互引用导致扩展性和可维护性都很差，而且难以测试。


模块边界被破坏

基础工程中心化

## 二 提出方案

### 2.1 模块架构

关于Android项目的实践，也一直是大家经常讨论的事情，从最宠的MVC、到MVP、MVVM，各种架构的目的都都是希望模块的耦合性更低、独立性更强，移植性更好。

Google自己也开了一个Repo来讨论这些框架的最佳实践，如下所示：

android-architecture：https://github.com/googlesamples/android-architecture

<img src="https://github.com/BeesAndroid/BeesAndroid/blob/master/art/practice/project/module/android_architecture.png"/>

我们今天中调讨论的就是MVP框架，这里也不去搬弄网上的那些关于MVP的概念，它的核心思想就是将视图逻辑I和业务逻辑相分离，达到解耦的目的。

👉 注：MVVM比MVP后出来，那么说明它比MVP更好，为什么我们还要去MVP呢，这是因为MVVM有个DataBinding的概念，虽然官方提供了库，但是这个在实际的项目中实践起来并不容量，相比之下MVP
更加简单。

官方的这个MVP框架的核心思想如下所示：

- 使用Contract接口统一管理View接口和Presenter接口的定义，当然这个也不是一定非得这么写，并不是每个View接口和Presenter接口都可以成对出现，可能会出现一个VIew接口对应介个Presenter接口或者
一个Presenter接口对应几个View接口的情况。
- 采用Fragment实现View接口，我们知道Presenter接口主要定义的是业务逻辑，例如：加载下一页、下拉刷新、编辑、提交、删除等，这些都是在页面的生命周期方法或者setXXXListener里调用的，Fragment的生命
周期正好可以用的上，而且Fragment还可以独立的填充到其他Activity里。

官方的这套框架存在两个问题：

- 正如上面所说的View接口交由Fragment实现，但是如果一个页面由多个独立的子页面组合而成，那是不是要在这个页面添加几个Fragment，这显示是不合理的，鉴于这种情况，我们可以
退而求其次，采用自定义View的方式来实现View接口。
- 当页面增大到一定的量级的时候，就出出现大量的Presenter实现类，其实大风车现有的工程就有很多的Presenter实现类，Presenter实现类和View实现类需要相互set，以便View可以调用Presenter加载数据
，Presenter调用View刷新UI，管理这些Presenter类是个很大的问题，而且如果别人要继承你这个View，你还要告诉它在View的生命周期里如何去处理Presenter的创建和销毁，以及何时去加载数据等等。
如果出现跨部门甚至跨跨城市的合作时，沟通成本就非常的高。

笔者认为一个设计良好的组件必须是自管理的，内部实现细节都外界完全透明，别人在调用这个组件的时候只用传递一些配置参数即可，如下所示：

```java
Component view = new Component.Builder()
                    .setXXX()
                    .setXXX()
                    .setXXX()
                    .build();
```

这样就成功把一个View构建成功了，它负责去展示业务的某一部分页面，自己去加载数据，自己去刷新UI，当页面销毁时，自己负责释放资源。它不仅可以添加到Fragment中去，还可以添加到Activity中，甚至
还可以添加到一个ViewGroup中去，灵活自由。

去掉Presenter的管理成本，并不意味着去掉Presenter中，只是把它放在了View内部，交由View对它进行管理。


Lifecycle Component官方文档：https://developer.android.com/topic/libraries/architecture/guide.html

这套框架有两个重要的原则：

- 任何不处理UI逻辑和用户交互的代码都不应该写到Activity或者Fragment中，因为Activity或者Fragment是十分脆弱的，低内存、配置发生变化、进入后台等等都可能导致它们的销毁，应该
最大限度的减低对Activity或者Fragment的依赖。
- 应该使用一个持久数据模型来驱动我们的UI，数据可以在该套模型里进行持久化，一旦Activity或者Fragment被销毁，用户数据不会丢失，这套模型专门用来处理数据逻辑，使应用的数据逻辑与视图逻辑
向分离，让应用变得更易维护。

👉 注：这里可能有人有疑问，非得用Lifecycle组件吗，利用View的onAttachToWindow()、onDetachToWindow()这些方法来模拟Activity或者Fragment的生命周期不可以吗，事实上View的生命周期在
一些特殊的场景下是不可靠的，例如：RecyclerView、ViewPager，所以我们还是需要利用Lifecycle组件来监听Activity或者Fragment的生命周期变化。


一个模块一般可以划分为三个部分：

- api：接口部分，提供对外的接口和数据结构。
- implementation：实现部分，提供对业务逻辑的实现，它往往和应用的状态、账户信息等息息相关，library为它提供具体的功能，它决定如何去加载、组织、以及展示这些功能。
- library：功能部分，为implementation提供一些具体的功能。

模块生命周期

1. 进程启动
2. Account初始化
3. Account注销
4. 进程退出

模块初始化流程

1. 添加依赖，依赖也分为两种：编译期依赖和运行期依赖，
2. 配置数据，注册服务。
3. 启动服务。

模块边界

### 2.1 模块解耦

模块解耦我们使用的是路由的方式

### 2.1 模块通信

解决了模块间的解耦问题，另一个就是模块间的通信问题。在一个大型的应用里很多模块都是可以独立运行甚至独立成一个App的，这就牵扯到模块间的数据交互和通信问题，例如：最常见的一种
场景就是子模块需要知道主应用里的登录信息等等，模块间的通信业可以分为两种情况：

- 进程内通信：模块都运行在同一个进程中。
- 跨进程通信：模块运行在不同的进程中。

#### 2.1.1 进程内通信

进程内通信的手段有很多种，最常见的就是EventBus，

EventBus：https://github.com/greenrobot/EventBus

> EventBus 用来完成 Activities, Fragments, Threads, Services 之间的数据交互和通信。

EventBus是早期页面通信和模块通信常见的手段，但是随着工程的膨胀，它的问题也凸显出来，具体说来：

- Event并非所有通信常见的最佳方式，它主要适合一对多的广播场景，如果业务中的通信需要一组接口时，就需要定义多个Event，代码复杂。
- 大量的Event的类，难以管理，如果应用越来越庞大，模块划分也越来越多，这个Event就变得难以维护。




除了EventBus以外，我们还可以选择LocalBroadcastReceiver。LocalBroadcastReceiver
是一个应用内的局域广播，它也是利用一个Looper Handler维护一个全局Map进行应用内部通信，与EventBus不同，它发送的是字符串。


#### 2.1.2 跨进程通信

跨进程通信可以借助Content Provider来完成，

Content Provider：https://developer.android.com/guide/topics/providers/content-providers.html

> Content Provider 底层采用的是Binder机制，用来完成进程间的数据交互和通信。

模块通信采用Content Provider的方式来解决。

## 三 解决问题

模块化拆分不是一个简单的事情，没法一蹴而就，也不可能让团队全部停下来去做拆分重构，所以真正实施模块化需要按照以下几个步骤循序渐进的进行。

### 3.1 心态调整

技术上的重构并不能带来短期上的收益，它是一个长时间才能显现好处的事情，你往往花费了很多时间来做这些事情，它也非常的有意义，但是老板看不到，业务上也不会带来明显的增长。所以
第一件事情，就是做好团队成员的思想工作。

事实上，大部分研发同学都还是非常有技术追求的，但是我们工程通常有很多历史遗留问题，也就是所谓的技术债，要去重构这些东西，成本是非常高的，面对这种情况在加上平时业务需求多，时间紧，大家
通常都会想：

> 重构难度这么大，出了问题怎么办，算了，别人怎么写，我也怎么写好了。

这是一个很普遍的现象，这种情况下就需要有一个有魄力的leader打响第一枪，有了第一个阶段的重构，大家看到了曙光，就会开始陆续吐槽原来的设计有多么烂，应该如何设计等等。

### 3.2 模块拆分

### 3.3 灰度发布

### 3.4 应用回流

## 附录

每个人认领自己的模块，对别人在该模块上做的修改予以监督。


最后啰嗦几句：

1. 能用原生实现的不要用第三方库实现，如果实在需要第三方库实现，例如：图片库、网络库，也不要直接使用，要做好封装和接口隔离，方便以后做替换。
2. 页面间的继承关系一定要谨慎，除非是专门为继承而设计的页面，否则应该考虑使用组合或其他侵入性更低的方式来解决问题。
3. 项目中为某个需求提出了解决方案时，如果这种需求其他团队还可能会遇到，就要评估一下这个方案耦合性怎么样，以后能否直接给其他团队使用，较少团队间
的重复劳动。
4. 对外提供的功能尽量做好接口封装，不要直接暴露内部细节，这样日后也可以直接替换内部逻辑，而不至于影响业务方。
